
import torch
from torch.utils.data import DataLoader
import pandas as pd

from models.multimodal import EnhancedMultimodalModel
from utils.dataset import MultimodalECGDataset
from utils.transforms import get_train_transform, get_test_transform
from utils.metrics import compute_metrics
from config import *

from sklearn.model_selection import train_test_split

def main():

    df = pd.read_csv(CSV_PATH)

    train_df, val_df = train_test_split(
        df, test_size=0.2, stratify=df["label"], random_state=42
    )

    train_dataset = MultimodalECGDataset(
        train_df,
        image_transform=get_train_transform(),
        tabular_features=df.columns[ df.columns.isin([
            "pulse", "sbp", "dbp", "height", "weight", "gender", "age"
        ]) ]
    )

    val_dataset = MultimodalECGDataset(
        val_df,
        image_transform=get_test_transform(),
        tabular_features=train_dataset.tabular_features
    )

    train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=BATCH_SIZE, shuffle=False)

    model = EnhancedMultimodalModel(num_tabular_features=7, num_classes=2)
    model = model.to(DEVICE)

    criterion = torch.nn.CrossEntropyLoss()
    optimizer = torch.optim.AdamW(model.parameters(), lr=LEARNING_RATE)

    history = {"train_loss": [], "val_loss": [], "train_acc": [], "val_acc": []}

    for epoch in range(NUM_EPOCHS):

        model.train()
        train_loss = 0
        correct = 0
        total = 0

        for images, tabs, labels in train_loader:
            images, tabs, labels = images.to(DEVICE), tabs.to(DEVICE), labels.to(DEVICE)

            optimizer.zero_grad()
            outputs = model(images, tabs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            train_loss += loss.item()
            _, preds = outputs.max(1)
            correct += preds.eq(labels).sum().item()
            total += labels.size(0)

        train_acc = correct / total

        # Validation
        model.eval()
        val_loss = 0
        correct = 0
        total = 0

        all_preds = []
        all_labels = []
        all_probs = []

        with torch.no_grad():
            for images, tabs, labels in val_loader:
                images, tabs, labels = images.to(DEVICE), tabs.to(DEVICE), labels.to(DEVICE)

                outputs = model(images, tabs)
                loss = criterion(outputs, labels)

                val_loss += loss.item()

                probs = torch.softmax(outputs, 1)
                _, preds = outputs.max(1)

                all_preds.extend(preds.cpu().numpy())
                all_labels.extend(labels.cpu().numpy())
                all_probs.extend(probs.cpu().numpy())

        metrics = compute_metrics(
            labels=np.array(all_labels),
            preds=np.array(all_preds),
            probs=np.array(all_probs)
        )

        val_acc = metrics["accuracy"]

        print(f"Epoch {epoch+1}: Train Loss {train_loss:.4f} | Val Loss {val_loss:.4f} | Train Acc {train_acc:.3f} | Val Acc {val_acc:.3f}")

        history["train_loss"].append(train_loss)
        history["val_loss"].append(val_loss)
        history["train_acc"].append(train_acc)
        history["val_acc"].append(val_acc)

    return history

if __name__ == "__main__":
    main()
